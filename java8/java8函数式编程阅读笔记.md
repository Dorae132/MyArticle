# java 8
>author:Dorae  
>date:2017年10月16日14:49:30

----
**<font color="red">接口变动、函数式接口、lambda表达式、流操作（外部迭代到内部迭代、并行操作）、Optional</font>**

+ Lambda表达式
+ 函数接口
+ 自定义函数接口
+ 常用流操作
+ 流与集合的区别
+ 集合类流操作的实现原理，内部迭代器，spliterator（并行迭代器）
+ 建造者模式
+ 尽量避免副作用，唯一例外的是foreach，因为其表示一个终结方法
+ Lambda表达式重载的工作原理
+ <font color="red">为什么Supplier<T>可以和匿名内部类一起工作，实现向后兼容？</font>
+ Java中的泛型基于对其是Object的假设，所以有了装箱类型
+ Java8中为了减少集合中频繁的装箱与拆箱操作，提供了相应的方法，Integer、Long、Double，应该尽量减少对装箱类型集合的操作（<font color="red">好像更慢了20倍左右，目前未知原因</font>）
+ Collectors.toMap()方法的merge只会保存一个元素(k1, k2) -> k1,那么只有k1会被保存
+ <font color="red">如何调试java8风格的代码</font>
+ Jva8提供了向后兼容（二进制兼容性，通过默认方法实现，默认方法与普通方法在继承规则上的区别）
	+ 默认方法只能通过调用子类的方法来修改子类本身，避免了对子类的各种假设
	+ 默认方法重写规则不同，可以说没有重写
	+ 一旦与类中定义的方法产生冲突，优先选择类中的方法（<font color="red">因为默认方法的主要目的是为了实现向后兼容</font>）
	+ 默认方法的多重继承会编译报错，可以使用interface.super来实现类似父类的操作
	+ 接口中的静态属性可以被继承，但是静态方法不能被继承，静态属性属于类而非实例
	+ 三定律
	+ 对于类而言，静态方法可以继承，不可以重写，不能实现多态（可以隐藏）；静态方法可以被自身引用调用，不能被父类引用调用（即使父类也有此方法），父类引用通过多态 （A b1 = new B()） 调用的是自己的静态方法。
	+ java中静态属性和静态方法可以被继承，但是没有被重写(overwrite)而是被隐藏. 
	+ 接口中的静态属性与类中的类似，但是静态方法有区别
	+ 对于类中的非静态属性不能实现多态，而非静态方法可以实现多态，是因为静态绑定（对属性，编译期绑定），动态绑定（方法，运行期），对于属性可以通过get方法来解决，但是子类与父类要同时声明
	+ 接口中的静态方法是为了更好的编写类库，组织代码结构
+ @FunctionalInterface接口的作用，方便以后重构发现问题，另外有些只有一个抽象方法的接口可能只是巧合为函数接口，例如持有某种状态的接口
+ 方法引用
+ 流中的元素顺序
	+出现顺序依赖于数据源和对流的操作 
+ 流的并行操作
+ 数据分块（partitioningBy）与分组(groupBy)，Collectors.joining